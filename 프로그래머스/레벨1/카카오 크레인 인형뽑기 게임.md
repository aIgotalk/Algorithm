# 카카오 - 크레인 인형뽑기 게임

### **문제설명**

게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해   
크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때,   
크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.  

### 제한 사항

- board 배열은 2차원 배열로 크기는 "5 x 5" 이상 "30 x 30" 이하입니다.
- board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.
    - 0은 빈 칸을 나타냅니다.
    - 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.
- moves 배열의 크기는 1 이상 1,000 이하입니다.
- moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.

---

### 입출력 예

![Untitled](https://user-images.githubusercontent.com/72185011/177358362-18ef06cf-0ae1-45c0-a1b7-d3d0e60efcb5.png)

---

### 생각

뭔가 넣고 빼는 문제라 회사에서 스택을 써야할거같았지만 한줄도 구현못하고 문제를 꺼버렸다. 배열 문제만 나오면 머리가 아프고 보기싫어진다. 이차원 배열이니 더 보기 싫어진다. 

어떻게 풀어야할까

![Untitled](%E1%84%8F%E1%85%A1%E1%84%8F%E1%85%A1%E1%84%8B%E1%85%A9%20-%20%E1%84%8F%E1%85%B3%E1%84%85%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%92%E1%85%A7%E1%86%BC%E1%84%88%E1%85%A9%E1%86%B8%E1%84%80%E1%85%B5%20%E1%84%80%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%B7%202cac5993bc7c4a9283e51f4521716b13/Untitled%201.png)

이중배열을 그려보면 다음과같은 표가 나오고 순서대로 뽑으면 바구니에 위와 같은 숫자가 담긴다.

스택 바로 위에 같은 숫자가 들어오면 사라지게되는데 1,1이 들어와서 사라지고 3,3이 들어와서 사라

지는 숫자는 총 4개가 된다.

바구니 담을 스택이 필요하고 같은숫자 만나서 스택에서 뽑을때 카운트해줄 정수형 변수하나 필요할거같다.  move만큼 for문으로 반복하면서 배열의 값이 0일때는 패스 시킨다. 0이 아니라면 바구니에 있는 값이랑 비교해서 같으면 날리고 count 증가시킨다. 다르면 stack에 넣어준다.

---

**Solution**

```java
class Solution {
    public int solution(int[][] board, int[] moves) {
        
        int answer = 0;
        
        Stack<Integer> stack = new Stack<>();
        
        for(int i=0; i<moves.length; i++){
            // 3-1. j 인덱스를 이용해 보드의 행을 탐색. 열은 moves의 원소를 이용해 탐색.
            for(int j=0;j<board.length;j++){
                // 3-2. j행의 moves의 크레인위치 열에 해당하는 값에 인형이 존재한다면.
                if(board[j][moves[i]-1] != 0 ) {                   
                    // 3-3. stack이 비어있지 않고, 현재 스택의 최상단에 있는 인형과 크레인으로 뽑은 인형이 같다면
                    if(!stack.empty() && stack.peek() == board[j][moves[i]-1]){
                        // 인형들을 제거하는 횟수 증가.
                        answer++;
                        // 바구니에 있는 인형을 제거.
                        stack.pop();
                        // 크레인으로 뽑은 인형을 0으로 만들어 없애준다.
                        board[j][moves[i]-1] = 0;
                        break;
                    // 3-4. 그 외의 경우는 인형을 바구니에 담은 후 0으로 없애준다.    
                    }else{
                        stack.push(board[j][moves[i]-1]);                      
                        board[j][moves[i]-1] = 0;
                        break;
                    }
                }                        
            }
        }
        
        return answer*2;
    }
}
```

### 결론

Stack과 for을 이용하여 풀 수 있는 문제다. stack.peak, stack.empty, stack.push만 알면 되고   
제약조건이 stack이 무조건 들어있어야된다는 조건때문에 if로 한번 체크 해줘야된다.   
