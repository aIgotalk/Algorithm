# [LV.1] 모의고사

## 서론

이전에 자바로 풀어할 때는 스트림 연산자를 활용하지 않고 풀이한 문제이긴 하지만, 코틀린으로 다시 풀어보면서 어떤 연산함수를 활용할지 고민해보게 되었습니다. 실제로 문제를 풀이하면서 연산자를 다루는 것에 흥미가 더해진 것 같습니다.



## **문제설명**

수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다.

1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, ...  
2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, ...  
3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, ...

1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.



## **입출력 예**



![image](https://user-images.githubusercontent.com/48594786/177588430-e09a062c-332b-4d98-9dbb-afc081d440a0.png)

 

## 제한사항

- 시험은 최대 10,000 문제로 구성되어있습니다.
- 문제의 정답은 1, 2, 3, 4, 5중 하나입니다.
- 가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.



### 작성한 코드

```kotlin
class Solution {
    
    fun solution(answers: IntArray): IntArray {
        val firstArray = intArrayOf(1, 2, 3, 4, 5)
        val secondArray = intArrayOf(2, 1, 2, 3, 2, 4, 2, 5)
        val thirdArray = intArrayOf(3, 3, 1, 1, 2, 2, 4, 4, 5, 5)
  
        val result = intArrayOf(
            answers.filterIndexed { index, num ->
                num == firstArray[index % 5]
            }.count(),
            answers.filterIndexed { index, num ->
                num == secondArray[index % 8]
            }.count(),
            answers.filterIndexed { index, num ->
                num == thirdArray[index % 10]
            }.count()
        )
        val max = result.maxOrNull()
        
        return result
            .mapIndexed { index, each ->
                if(max == each) index + 1
                else -1
            }
            .filter { it != -1 }
            .sorted()
            .toIntArray()
    }
    
}
```

## 

## 접근방법

1. 문제를 보고 가장 빠르게 생각한 것은 수포자는 총 3명이고 3명 중 answers의 패턴과 가장 많이 일치하는 수포자를 반환하는 것이기 때문에, 반환 값이 최소 1개이거나 최대 3개의 값을 가진 배열이라는 것입니다.

2. 저는 우선 1번, 2번, 3번 수포자가 찍는 방식의 최소 반복 패턴을 배열로 구성하였습니다. 위 문장에서 칭한 최소 반복패턴이란, 일정한 주기로 반복하는 패턴을 의미합니다.

3. 입력으로 받는 answers는 최대 10,000문제로 구성되어 있고, 몇개의 문제가 들어올지 모르기 때문에 answers를 기준으로 잡았습니다. (answers를 바깥 Scope에 위치시킨 것을 의미합니다)

4. 우선 3개의 값을 가진 result 배열을 구성합니다. 예를 들면, 0번째 인덱스에서 얻고자 하는 값은 answers와 1번째 수포자의 정답이 몇개가 일치하는지 찾는 것이고 1번째, 2번째 인덱스에서 얻고자 하는 값도 각각 2번째 수포자, 3번째 수포자와 얼마나 일치하는지를 확인 하고자 합니다.
   
   4-1) 여기서 중요한 것은 각 수포자들은 자기만의 최소 반복 패턴을 가지고 있고 각각 반복되는 주기가 다르다는 것 입니다. answers에 filterIndexed를 활용한 이유는 각 수포자들의 정답이 일치하는 것들을 필터링함과 동시에 최소 반복 패턴에 % 연산자를 사용하여  각 인덱스에 맞는 정답을 확인하고자 했습니다.
   
   4-2) 필터링이 끝나면 일치하는 문제들만 새로운 배열로 구성될 것이고 count() 함수를 이용하여 새롭게 구성된 배열이 각각 몇개씩인지 확인합니다. 
   
   4-3) result 배열에서 가장 큰 값이 무엇인지 확인하여 max 변수에 저장합니다.
   
   4-4) result를 기준으로 mapIndexed 연산자를 활용하여 각 수포자가 맞춘 정답이 max값과 동일하다면 인덱스를 반환하고 그렇지 않으면 -1을 반환합니다. 다시 filter 함수를 활용하여 -1이 아닌 것만으로 재구성합니다.
   
   4-5) 문제에서 제한 조건중에 가장 높은 점수를 받은 사람이 여럿일 경우, 오름차순 정렬하여 반환하라고 했기 때문에 정렬시켜 반환합니다.

## 

### 결론

어려운 문제는 아니였습니다. 하지만, 알고리즘을 구성할때 map, filter, sort, max, count 함수들을 활용해보면서 코틀린 언어의 강력함을 다시 한 번 느낄 수 있었습니다. 물론, 코틀린만의 장점은 아닐 것입니다. 하지만 코드가 물흐르는 듯이 깔끔하고 개연성 있어 보이는 느낌이 많이 들었습니다.
