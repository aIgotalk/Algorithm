# [LV.1] 키패드 누르기

## 서론

이 문제는 실제 2020년도 카카오 인턴에 합격했을때에 코딩테스트로 출제되었던 문제입니다. 총 5문제 중, 1번 문제로 출제되었던 것으로 기억하고 이 문제에서 핵심은 거리차를 어떻게 계산할지 생각을 해야하는 문제입니다. 그 때 당시에는 실전이라 떨려서(?) 그랬는지 모르겠는데 쉬운 방법으로 접근하지 못하고 BFS로 거리차를 계산했었습니다. 이제는 거리차를 구할 때 간단한 연산을 통해 코드를 개선해서 작성해보도록 하겠습니다.



## **문제설명**

![image](https://user-images.githubusercontent.com/48594786/177579126-97b9a9f2-79fa-4499-b4d9-b14bc503f1a9.png)

위의 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자를 입력해야 합니다.
맨 처음 왼손 엄지손가락은 `*` 키패드에 오른손 엄지손가락은 `#` 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.

1. 엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다.
2. 왼쪽 열의 3개의 숫자 `1`, `4`, `7`을 입력할 때는 왼손 엄지손가락을 사용합니다.
3. 오른쪽 열의 3개의 숫자 `3`, `6`, `9`를 입력할 때는 오른손 엄지손가락을 사용합니다.
4. 가운데 열의 4개의 숫자 `2`, `5`, `8`, `0`을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.  
   4-1. 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.

순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요.



## **입출력 예**



![image](https://user-images.githubusercontent.com/48594786/177578973-e022f1ec-36ba-4a02-a34c-b711c2410e03.png)

 

## 제한사항

- numbers 배열의 크기는 1 이상 1,000 이하입니다.
- numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다.
- hand는 `"left"` 또는 `"right"` 입니다.
  - `"left"`는 왼손잡이, `"right"`는 오른손잡이를 의미합니다.
- 왼손 엄지손가락을 사용한 경우는 `L`, 오른손 엄지손가락을 사용한 경우는 `R`을 순서대로 이어붙여 문자열 형태로 return 해주세요.



### 작성한 코드

```kotlin
import kotlin.math.*

class Solution {
    
    fun solution(numbers: IntArray, hand: String): String {
        val leftList = listOf(1,4,7)
        val rightList = listOf(3,6,9)
        var leftX = 3; var leftY = 0
        var rightX = 3; var rightY = 2
        val answer = StringBuilder()
        
        for(number in numbers) {
            if(number in leftList) {
                answer.append('L')
                leftX = number / 3
                leftY = 0
            } else if(number in rightList) {
                answer.append('R')
                rightX = number / 3 - 1
                rightY = 2
            } else {
                val midX = if(number == 0) 3 else number / 3
                val midY = 1
                val distanceFromLeftHand = abs(leftX - midX) + abs(leftY - midY)
                val distanceFromRightHand = abs(rightX - midX) + abs(rightY - midY)
                
                if(distanceFromLeftHand == distanceFromRightHand) {
                    if(hand == "left") {
                        answer.append('L')    
                        leftX = midX
                        leftY = midY
                    } else {
                        answer.append('R')
                        rightX = midX
                        rightY = midY
                    }
                } else if (distanceFromLeftHand < distanceFromRightHand) {
                    answer.append('L')    
                    leftX = midX
                    leftY = midY
                } else {
                    answer.append('R')
                    rightX = midX
                    rightY = midY
                }
            }
        }
        
        return answer.toString()
    }
} 
```

## 

## 접근방법

1. 문제를 읽어보면 왼손과 오른손을 움직여서 어떤손으로 키보드를 눌렀는지 알아야 합니다. 여기서 키패드를 좌표로 사용해야 겠다는 생각을 할 줄 알아야합니다. 
   
   1-1) 4 x 3 배열을 떠올려서 처음 시작시 왼손은 (3, 0) 지점, 오른손은 (3, 2) 지점에 놓도록 합니다.
   
   1-2) 키패드에 나와있는 1, 2, 3 ... 9, 0의 숫자를 어떻게 좌표로 구성할까?를 고민해야 합니다. 
   
   1-3) 잘 보면 규칙이 있습니다. 한 줄에 3개의 숫자가 있으니 몇 번째 행인지 알고 싶으면, (숫자 % 3) 연산을 하면 됩니다. 
   
   1-4) 왼손인 경우를 예를 들면, 왼손이 1을 선택하는건 배열상 (0, 0) 지점에 있기 때문에 (1 / 3, 0) 이라고 생각하면 됩니다. 이러한 가정은 다른 케이스에도 적용이 되어야 합니다. 왼손이 7을 선택한 경우는 좌표상으로 (2, 0) 입니다. 위의 식을 적용해보면, (7 / 3, 0) 이기 때문에 (2, 0) 으로 일치합니다. 우리가 정한식으로 해당 번호의 좌표를 구할 수 있게 되었습니다.
   
   1-5) 오른손인 경우를 예를 들면, 오른손으로 3을 선택할땐 좌표상으로 (0, 2)입니다. 이 경우에는 (3 % 3 - 1, 0) 이라고 생각하면 됩니다. 이러한 가정은 다른 케이스에도 적용이 되어야 합니다. 오른손이 6을 선택하는 경우는 좌표상으로 (1, 2) 입니다. (6 % 3 - 1, 2) 로 우리가 정한 식으로 해당 번호의 좌표를 구할 수 있게 되었습니다.
   
   1-6) 2, 5, 8, 0의 숫자의 좌표중 0을 제외하고는, 왼손의 좌표를 구하는 것처럼 1,4, 7의 좌표를 구할 때 처럼 (2 / 3, 1), (5 / 3, 1), (8 / 3, 1) 구할 수 있게 됩니다. 하지만 0의 좌표는 위의 식으로 좌표를 구할 수 없기 때문에 따로 분기처리를 해주어야 합니다.
   
   

2. 위의 방식대로 왼손과 오른손의 좌표를 구해서 문제에 맞게 알고리즘을 구현해 나가면 됩니다. 하지만, 여기서 가장 중요한건 숫자 2, 5, 8, 0을 선택할 때는 왼손과 오른손이 있는 좌표의 거리차를 계산해서 어떤 손을 선택할지 확인해야하고, 거리차가 동일하다면 파라미터 hand에 따라 달라지는 알고리즘을 구성하는 것 입니다.



3. 거리를 구하는 공식은 꽤나 간단하게 구할 수 있습니다. 
   
   수학시간애 배운 (x1, y1)의 좌표와 (x2, y2)의 좌표의 거리 구하는 공식을 조금 활용하면 됩니다. 수학시간에 배운 거리를 구하는 공식은 ((x2 - x1)^2 + (y2 - y1)^2)의 제곱근으로 알고있지만, 실제로 문제에서 좌표가 이동하는 거리는 x좌표 또는 y좌표로 1칸 이동하기 때문에, (1, 1) 와 (2, 2)의 거리차는 2라고 생각하시면 됩니다. 따라서, 문제에서 거리차를 구하는 공식은 Math.abs(x1 - x2) + Math.abs(y1 - y2)로 정의 할 수 있습니다.



4. 위의 공식을 통해 2, 5, 8, 0의 숫자가 나올때는, 왼손과 오른손의 현재 좌표에서 해당 번호의 숫자 좌표를 구해 거리차를 비교하여 알고리즘을 구성하면 됩니다.



+ 추가적으로, 사소한 차이지만 반환 값을 저장하기위해 StringBuilder를 사용하였습니다.

+ String과 StringBuilder의 값 저장 원리에 대해서 이해해보는 것도 좋을 것 같습니다.
  
   

### 결론

약 2년만에 보는 문제인데, 다시 풀어보니 더 쉽게 풀리는 느낌이긴 하다.

지금 생각해보면 그때 4번 보물찾기(?) 효율성 문제에서 꽤나 시간이 오래 걸렸었는데, 테스트 종료 약 1분정도 남기고 짜릿하게 해결했던 것으로 기억한다. 결과적으로, 코딩테스트 컷은 5문제중 3.5 솔이였지만 1번 문제와 2번문제를 빠르게 해결한 덕분에 나머지 문제에 시간을 충분이 할애할 수 있었던 것 같다.

1번 문제나 2번 문제에서 구현 문제가 나온다면, 자기만의 아이디어로 빠르고 정확하게 해결해서, 집중력과 추진력을 얻는 것도 코딩테스트 실전에 매우 중요한 것 같다. (왜냐하면 코딩테스트 실전은 연습할때의 체감과는 매우 다르기 때문에, 1번부터 쩔쩔매면 그 테스트는 종료 될때까지 어느 문제에 집중할 수 없게 된다)
