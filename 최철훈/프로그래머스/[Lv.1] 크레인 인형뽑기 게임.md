# [LV.1] 크레인 인형뽑기 게임

## 서론

이 문제는 5번정도 풀어본 문제입니다. 2차원 배열이 주어질 때, 해당 값들을 어떻게 참조하여 사용할지 그리고 크레인으로 뽑은 인형을 바구니에 저장할 때 어떤 자료구조를 이용하여 효율적으로 값을 관리할 수 있을지를 묻는 의도를 가진 문제입니다.


## **문제설명**

게임 화면은 **"1 x 1"** 크기의 칸들로 이루어진 **"N x N"** 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 "5 x 5" 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 "1 x 1" 크기의 격자 한 칸을 차지하며 **격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다.** 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.

만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 **두 개**가 없어집니다.

크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)

게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.


## **입출력 예**

![image](https://user-images.githubusercontent.com/48594786/178150676-904b0824-66a5-4a82-ad55-2c1dc900d29e.png)


## 제한사항

- board 배열은 2차원 배열로 크기는 "5 x 5" 이상 "30 x 30" 이하입니다.
- board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.
  - 0은 빈 칸을 나타냅니다.
  - 1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.
- moves 배열의 크기는 1 이상 1,000 이하입니다.
- moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.


## 작성한 코드

```kotlin
import java.util.*

class Solution {
    
    fun solution(board: Array<IntArray>, moves: IntArray): Int {
        var answer = 0
        val stack = Stack<Int>()
        
        moves.forEach { i ->
            for(j in board.indices) {
                if(board[j][i-1] != 0) {
                    if(stack.isNotEmpty() && (stack.peek() == board[j][i-1])) {
                        answer += 2
                        stack.pop()
                    } else {
                        stack.push(board[j][i-1])
                    }
                    
                    board[j][i-1] = 0
                    
                    break
                }
            }
        }
        
        return answer
    }
    
}
```


## 접근방법

1. 우선 문제를 읽어보면 입력 moves 은 인형을 뽑기 위해 어떤 열을 선택할지에 대한 값을 가지고 있습니다. 그래서 moves 배열의 사이즈만큼 반복문을 돌아야 하는 것을 확인할 수 있고, 이 반복문은 가장 바깥 Scope에 위치해야 함을 알 수 있습니다.
   
   1-1) 배열값들은 열에 대한 Index를 나타내기 때문에, 저는 forEach문을 사용하였습니다.

2. 1번에서 moves의 배열값은 어떤 열을 선택할지에 대한 값이라고 설명드렸습니다. (x, y)를 기준으로 보면 y값이 열에 대한 Index를 의미하기 때문에, y값은 고정된 채로 x값을 Top부터 Bottom까지 탐색을 해야합니다.
   
   2-1) 그래서 board 배열을 활용하여 board[j][i] 값을 탐색합니다. 여기서 i값은 moves 각 인덱스 값을 나타냅니다.
   
   2-2) j값은 board의 행의 사이즈만큼 반복문을 통해 확인합니다.
   
   2-3) board[j][i]의 값이 0인 경우는 비어있는 경우이기 때문에, 비어있지 않을때까지 값을 탐색해 나갑니다.
   
   2-4) board[j][i]의 값이 0이 아닌경우는 인형이 존재하는 경우이고, 이 때 크레인을 이용하여 해당 인형을 바구니로 이동시킵니다.

3. 크레인으로 이동을 이동시킬 때, Stack이라는 자료구조를 활용하였습니다. 기존에 저장되어 있는 맨 위에 있는 인형이 이동시키려는 인형과 일치하면 해당 인형들은 터지면서 사라져야 합니다.
   
   3-1) Stack이 비어있으면, 크레인으로 이동시킬 인형을 넣어주면 됩니다.
   
   3-2) Stack이 비어있지 않고, 맨위의 인형이 크레인으로 이동시킬 인형과 일치하지 않으면, 인형을 넣어주면 됩니다.
   
   3-3) Stack이 비어있지 않고, 맨위의 인형이 크레인으로 이동시킬 인형과 일치하면 Stack의 맨위의 인형을 단순히 제거해주기만 하면 됩니다. 이것은 문제에서 인형이 일치하면 터뜨린다는 것을 의미합니다.
   
   3-4) 공통적으로, 인형을 이동시켰으면 board[j][i]에는 인형이 이동되었기 때문에, 비었다는 것을 나타내기 위해 값을 0으로 업데이트 합니다.



- 여기서 Stack이라는 자료구조를 꼭 활용할 필요는 없습니다. List나 Dequeue 등의 자료구조로도 문제를 해결할 수는 있습니다.

- 다만, 문제 출제의 의도를 파악하고 어떤 자료구조를 쓰는 것이 효율적인지는 충분히 생각해보는게 좋다고 생각합니다.

- 왜냐하면, 효율적인 자료구조를 활용하면 시간/공간 복잡도를 개선할 수 있을 뿐만 아니라 문제를 풀어나가는 과정이 좀 더 간결해질 수 있기 때문입니다. 더 나아가서는 자료구조와 알고리즘의 이해도를 높일 수 있는 과정이라고 생각합니다.


## 결론

자바와 코틀린으로 문제를 여러번 풀어보면서, 코드가 점점 더 간결해짐을 느꼈고, 결국 출제자가 의도한 코드는 딱 정해져 있음이 느껴지는 문제였습니다. 이러한 문제를 코딩 테스트에서 접하게 된다면, 실수없이 빠르게 풀어나가야 하는 문제임에 틀림없다고 생각합니다.
